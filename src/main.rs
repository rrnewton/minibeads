mod format;
mod hash;
mod lock;
mod storage;
mod sync;
mod types;

// Include build-time information generated by build.rs
mod built_info {
    include!(concat!(env!("OUT_DIR"), "/built.rs"));
}

use anyhow::{Context, Result};
use clap::{Parser, Subcommand};
use std::collections::HashMap;
use std::env;
use std::path::{Path, PathBuf};
use storage::Storage;
use types::{DependencyType, IssueType, Status};

/// Generate long version string with git info and build date
fn long_version() -> &'static str {
    // Allocate version string at runtime, leak it to get 'static lifetime
    // This is called once during CLI initialization
    Box::leak(
        {
            let mut version = env!("CARGO_PKG_VERSION").to_string();

            // Add build date from compile time
            version.push_str(&format!("\nBuilt: {}", env!("BUILD_DATE")));

            // Add git commit if available and working copy is clean
            if let (Some(commit), Some(false)) =
                (built_info::GIT_COMMIT_HASH_SHORT, built_info::GIT_DIRTY)
            {
                version.push_str(&format!("\nCommit: {}", commit));
            }

            version
        }
        .into_boxed_str(),
    )
}

#[derive(Parser)]
#[command(
    name = "bd",
    about = "Minibeads - A minimal issue tracker",
    long_version = long_version(),
)]
struct Cli {
    /// Path to .beads directory (minibeads-specific, preferred over --db)
    #[arg(long = "mb-beads-dir", global = true)]
    mb_beads_dir: Option<PathBuf>,

    /// Path to database (for upstream compatibility - use --mb-beads-dir instead)
    /// Treated as syntactic sugar for specifying the .beads directory.
    /// When path ends with .db, the parent directory is used.
    #[arg(long, global = true)]
    db: Option<PathBuf>,

    /// Actor name for audit trail
    #[arg(long, global = true)]
    actor: Option<String>,

    /// Output JSON format
    #[arg(long, global = true)]
    json: bool,

    /// Validation mode for parsing issues (minibeads-specific)
    #[arg(
        long = "mb-validation",
        global = true,
        default_value = "error",
        value_name = "MODE"
    )]
    mb_validation: ValidationMode,

    /// Disable command logging to .beads/command_history.log (minibeads-specific)
    #[arg(long = "mb-no-cmd-logging", global = true)]
    mb_no_cmd_logging: bool,

    /// Disable auto-flush (ignored for compatibility)
    #[arg(long, global = true)]
    no_auto_flush: bool,

    /// Disable auto-import (ignored for compatibility)
    #[arg(long, global = true)]
    no_auto_import: bool,

    #[command(subcommand)]
    command: Commands,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum ValidationMode {
    Silent,
    Warn,
    Error,
}

impl std::str::FromStr for ValidationMode {
    type Err = anyhow::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "silent" => Ok(ValidationMode::Silent),
            "warn" => Ok(ValidationMode::Warn),
            "error" => Ok(ValidationMode::Error),
            _ => Err(anyhow::anyhow!(
                "Invalid validation mode: '{}'. Valid values are: silent, warn, error",
                s
            )),
        }
    }
}

#[derive(Subcommand)]
enum Commands {
    /// Initialize beads in current directory
    Init {
        /// Issue prefix (e.g., 'myproject' for myproject-1, myproject-2)
        #[arg(short, long)]
        prefix: Option<String>,

        /// Use hash-based issue IDs instead of sequential numbers (minibeads-specific)
        #[arg(long = "mb-hash-ids")]
        mb_hash_ids: bool,
    },

    /// Create a new issue
    Create {
        /// Issue title
        title: String,

        /// Priority (0-4, 0=highest)
        #[arg(short, long, default_value = "2")]
        priority: i32,

        /// Issue type
        #[arg(short = 't', long, default_value = "task")]
        issue_type: IssueType,

        /// Description
        #[arg(short, long, default_value = "", allow_hyphen_values = true)]
        description: String,

        /// Design notes
        #[arg(long, allow_hyphen_values = true)]
        design: Option<String>,

        /// Acceptance criteria
        #[arg(long, allow_hyphen_values = true)]
        acceptance: Option<String>,

        /// Assignee
        #[arg(short = 'a', long)]
        assignee: Option<String>,

        /// Labels (can be specified multiple times)
        #[arg(short, long)]
        label: Vec<String>,

        /// External reference
        #[arg(long)]
        external_ref: Option<String>,

        /// Explicit issue ID
        #[arg(long)]
        id: Option<String>,

        /// Dependencies (comma-separated). Formats:
        /// Simple: "bd-1,bd-2" (defaults to 'blocks')
        /// Advanced: "blocks:bd-1,related:bd-2,discovered-from:bd-3"
        #[arg(long)]
        deps: Option<String>,
    },

    /// List issues
    List {
        /// Filter by status
        #[arg(short = 's', long)]
        status: Option<Status>,

        /// Filter by priority
        #[arg(short = 'p', long)]
        priority: Option<i32>,

        /// Filter by type
        #[arg(long)]
        r#type: Option<IssueType>,

        /// Filter by assignee
        #[arg(long)]
        assignee: Option<String>,

        /// Filter by labels (must have ALL specified labels)
        #[arg(short = 'l', long = "label")]
        labels: Vec<String>,

        /// Filter by specific issue IDs (comma-separated)
        #[arg(long)]
        id: Option<String>,

        /// Filter by title substring (case-insensitive)
        #[arg(long)]
        title: Option<String>,

        /// Maximum number of issues to return
        #[arg(long)]
        limit: Option<usize>,
    },

    /// Show issue details
    Show {
        /// Issue IDs (supports shorthand: "14" expands to "prefix-14")
        issue_ids: Vec<String>,
    },

    /// Update one or more issues
    Update {
        /// Issue IDs to update
        issue_ids: Vec<String>,

        /// New status
        #[arg(short = 's', long)]
        status: Option<Status>,

        /// New priority
        #[arg(short, long)]
        priority: Option<i32>,

        /// New assignee
        #[arg(short = 'a', long)]
        assignee: Option<String>,

        /// New title
        #[arg(long, allow_hyphen_values = true)]
        title: Option<String>,

        /// New description
        #[arg(short, long, allow_hyphen_values = true)]
        description: Option<String>,

        /// New design notes
        #[arg(long, allow_hyphen_values = true)]
        design: Option<String>,

        /// New acceptance criteria
        #[arg(long, allow_hyphen_values = true)]
        acceptance: Option<String>,

        /// Additional notes
        #[arg(long, allow_hyphen_values = true)]
        notes: Option<String>,

        /// New external reference
        #[arg(long)]
        external_ref: Option<String>,
    },

    /// Close one or more issues
    Close {
        /// Issue IDs to close
        issue_ids: Vec<String>,

        /// Reason for closing
        #[arg(short, long, default_value = "Completed", allow_hyphen_values = true)]
        reason: String,
    },

    /// Reopen closed issues
    Reopen {
        /// Issue IDs to reopen
        issue_ids: Vec<String>,

        /// Reason for reopening
        #[arg(short, long, allow_hyphen_values = true)]
        reason: Option<String>,
    },

    /// Rename an issue ID
    Rename {
        /// Current issue ID
        old_id: String,

        /// New issue ID
        new_id: String,

        /// Preview changes without applying them
        #[arg(long)]
        dry_run: bool,

        /// Repair broken references (scan all issues and fix stale references)
        #[arg(long)]
        repair: bool,
    },

    /// Rename the issue prefix for all issues
    RenamePrefix {
        /// New prefix to use
        new_prefix: String,

        /// Preview changes without applying them
        #[arg(long)]
        dry_run: bool,

        /// Force rename even if issues would conflict
        #[arg(long)]
        force: bool,
    },

    /// Manage dependencies
    Dep {
        #[command(subcommand)]
        command: DepCommands,
    },

    /// Get statistics
    Stats,

    /// Get blocked issues
    Blocked,

    /// Export issues to JSONL format
    Export {
        /// Output file path (defaults to stdout)
        #[arg(short = 'o', long)]
        output: Option<PathBuf>,

        /// Use default file output (.beads/issues.jsonl) instead of stdout
        #[arg(long = "mb-output-default")]
        mb_output_default: bool,

        /// Filter by status
        #[arg(long)]
        status: Option<Status>,

        /// Filter by priority
        #[arg(long)]
        priority: Option<i32>,

        /// Filter by type
        #[arg(long)]
        r#type: Option<IssueType>,

        /// Filter by assignee
        #[arg(long)]
        assignee: Option<String>,
    },

    /// Bidirectional sync between markdown and JSONL formats
    Sync {
        /// Path to JSONL file (defaults to .beads/issues.jsonl)
        #[arg(long)]
        jsonl: Option<PathBuf>,

        /// Preview changes without applying them
        #[arg(long)]
        dry_run: bool,

        /// Direction: 'both' (default), 'to-jsonl', or 'to-markdown'
        #[arg(long, default_value = "both")]
        direction: String,
    },

    /// Find ready work (issues with no blockers)
    Ready {
        /// Filter by assignee
        #[arg(short = 'a', long)]
        assignee: Option<String>,

        /// Filter by priority
        #[arg(short, long)]
        priority: Option<i32>,

        /// Maximum number of issues to return
        #[arg(short = 'n', long, default_value = "10")]
        limit: usize,

        /// Sort policy: priority (by priority), oldest (by creation date), hybrid (priority + age)
        #[arg(short = 's', long, default_value = "hybrid")]
        sort: String,
    },

    /// Show quickstart guide
    Quickstart,

    /// Show version information
    Version,
}

#[derive(Subcommand)]
enum DepCommands {
    /// Add a dependency
    Add {
        /// Issue that has the dependency
        issue_id: String,

        /// Issue that issue_id depends on
        depends_on_id: String,

        /// Dependency type
        #[arg(short = 't', long, default_value = "blocks")]
        r#type: DependencyType,
    },

    /// Remove a dependency
    Remove {
        /// Issue that has the dependency
        issue_id: String,

        /// Issue that issue_id depends on (to remove)
        depends_on_id: String,
    },

    /// Show dependency tree
    Tree {
        /// Issue ID to show tree for (supports shorthand: "14" expands to "prefix-14")
        issue_id: String,

        /// Maximum tree depth to display (safety limit)
        #[arg(short = 'd', long, default_value = "50")]
        max_depth: usize,

        /// Show all paths to nodes (no deduplication for diamond dependencies)
        #[arg(long)]
        show_all_paths: bool,
    },

    /// Detect dependency cycles
    Cycles,
}

/// Print a dependency tree in a visual format
fn print_dependency_tree(node: &types::TreeNode, depth: usize, prefix: &str, is_last: bool) {
    // Print the current node
    let connector = if depth == 0 {
        ""
    } else if is_last {
        "└── "
    } else {
        "├── "
    };

    let dep_type_str = if let Some(ref dt) = node.dep_type {
        format!(" ({})", dt)
    } else {
        String::new()
    };

    let suffix = if node.is_cycle {
        " [CYCLE DETECTED]"
    } else if node.depth_exceeded {
        " [MAX DEPTH EXCEEDED]"
    } else {
        ""
    };

    println!(
        "{}{}{}: {} [{}] (P{}){}{}",
        prefix, connector, node.id, node.title, node.status, node.priority, dep_type_str, suffix
    );

    // Don't recurse if cycle or depth exceeded
    if node.is_cycle || node.depth_exceeded {
        return;
    }

    // Print children
    let child_prefix = if depth == 0 {
        String::new()
    } else if is_last {
        format!("{}    ", prefix)
    } else {
        format!("{}│   ", prefix)
    };

    for (i, child) in node.children.iter().enumerate() {
        let is_last_child = i == node.children.len() - 1;
        print_dependency_tree(child, depth + 1, &child_prefix, is_last_child);
    }
}

fn main() {
    if let Err(e) = run() {
        eprintln!("Error: {:#}", e);
        std::process::exit(1);
    }
}

fn run() -> Result<()> {
    let cli = Cli::parse();

    // Extract fields needed for get_storage before matching on cli.command
    // This avoids borrowing issues when we try to call get_storage(mb_beads_dir, db) inside match arms
    let mb_beads_dir = &cli.mb_beads_dir;
    let db = &cli.db;
    let json = cli.json;
    let mb_no_cmd_logging = cli.mb_no_cmd_logging;

    match cli.command {
        Commands::Init {
            prefix,
            mb_hash_ids,
        } => {
            // IMPORTANT: init always creates .beads in current directory
            // It does NOT use find_beads_dir() or respect --db/--mb-beads-dir flags
            // This ensures init always initializes in CWD, never in ancestor directories
            if mb_beads_dir.is_some() || db.is_some() {
                eprintln!("Note: 'bd init' always creates .beads/ in current directory");
                eprintln!("      --db and --mb-beads-dir flags are ignored for 'init'");
            }

            let beads_dir = PathBuf::from(".beads");
            let storage = Storage::init(beads_dir, prefix, mb_hash_ids)?;

            // Log command after successful init
            if !mb_no_cmd_logging {
                let _ = log_command(&storage.get_beads_dir(), &env::args().collect::<Vec<_>>());
            }

            if !json {
                println!(
                    "Initialized beads database with prefix: {}",
                    storage.get_prefix()?
                );
            }
            Ok(())
        }

        Commands::Create {
            title,
            priority,
            issue_type,
            description,
            design,
            acceptance,
            assignee,
            label,
            external_ref,
            id,
            deps,
        } => {
            let storage = get_storage(mb_beads_dir, db)?;

            // Log command after storage is validated
            if !mb_no_cmd_logging {
                let _ = log_command(&storage.get_beads_dir(), &env::args().collect::<Vec<_>>());
            }

            // Parse dependencies
            // Supports two formats:
            // 1. Simple: "bd-1,bd-2" (defaults to 'blocks' type)
            // 2. Advanced: "blocks:bd-1,related:bd-2,discovered-from:bd-3"
            let parsed_deps = if let Some(deps_str) = deps {
                deps_str
                    .split(',')
                    .filter_map(|s| {
                        let s = s.trim();
                        if s.is_empty() {
                            return None;
                        }

                        // Check if it contains a colon (advanced format)
                        if let Some(colon_idx) = s.find(':') {
                            let (type_str, id) = s.split_at(colon_idx);
                            let id = id[1..].trim(); // Skip the colon

                            // Parse the dependency type
                            match type_str.parse::<DependencyType>() {
                                Ok(dep_type) => Some((id.to_string(), dep_type)),
                                Err(_) => {
                                    eprintln!(
                                        "Warning: Invalid dependency type '{}', skipping '{}'",
                                        type_str, s
                                    );
                                    None
                                }
                            }
                        } else {
                            // Simple format: just the ID, default to Blocks
                            Some((s.to_string(), DependencyType::Blocks))
                        }
                    })
                    .collect()
            } else {
                Vec::new()
            };

            let issue = storage.create_issue(
                title,
                description,
                design,
                acceptance,
                priority,
                issue_type,
                assignee,
                label,
                external_ref,
                id,
                parsed_deps,
            )?;

            if json {
                println!("{}", serde_json::to_string_pretty(&issue)?);
            } else {
                println!("Created issue: {}", issue.id);
            }
            Ok(())
        }

        Commands::List {
            status,
            priority,
            r#type,
            assignee,
            labels,
            id,
            title,
            limit,
        } => {
            let storage = get_storage(mb_beads_dir, db)?;

            // Log command after storage is validated
            if !mb_no_cmd_logging {
                let _ = log_command(&storage.get_beads_dir(), &env::args().collect::<Vec<_>>());
            }

            let mut issues =
                storage.list_issues(status, priority, r#type, assignee.as_deref(), None)?;

            // Apply label filter (must have ALL specified labels)
            if !labels.is_empty() {
                issues.retain(|issue| labels.iter().all(|label| issue.labels.contains(label)));
            }

            // Apply ID filter (comma-separated list of specific IDs)
            if let Some(id_filter) = id {
                let target_ids: Vec<String> =
                    id_filter.split(',').map(|s| s.trim().to_string()).collect();
                issues.retain(|issue| target_ids.contains(&issue.id));
            }

            // Apply title filter (case-insensitive substring match)
            if let Some(title_filter) = title {
                let title_lower = title_filter.to_lowercase();
                issues.retain(|issue| issue.title.to_lowercase().contains(&title_lower));
            }

            // Apply limit if specified
            if let Some(limit_val) = limit {
                issues.truncate(limit_val);
            }

            if json {
                println!("{}", serde_json::to_string_pretty(&issues)?);
            } else {
                for issue in issues {
                    println!(
                        "{}: {} [{}] (priority: {})",
                        issue.id, issue.title, issue.status, issue.priority
                    );
                }
            }
            Ok(())
        }

        Commands::Show { issue_ids } => {
            let storage = get_storage(mb_beads_dir, db)?;

            // Log command after storage is validated
            if !mb_no_cmd_logging {
                let _ = log_command(&storage.get_beads_dir(), &env::args().collect::<Vec<_>>());
            }

            if issue_ids.is_empty() {
                anyhow::bail!("No issue IDs provided. Usage: bd show <issue-id> [issue-ids...]");
            }

            let prefix = storage.get_prefix()?;
            let mut issues = Vec::new();

            // Normalize issue IDs (expand numeric shorthand like "14" -> "prefix-14")
            for id_str in &issue_ids {
                let normalized_id = if id_str.parse::<u32>().is_ok() {
                    format!("{}-{}", prefix, id_str)
                } else {
                    id_str.clone()
                };

                let issue = storage
                    .get_issue(&normalized_id)?
                    .ok_or_else(|| anyhow::anyhow!("Issue not found: {}", normalized_id))?;
                issues.push(issue);
            }

            if json {
                println!("{}", serde_json::to_string_pretty(&issues)?);
            } else {
                for (idx, issue) in issues.iter().enumerate() {
                    if idx > 0 {
                        println!("\n{}", "=".repeat(70));
                        println!();
                    }

                    println!("ID: {}", issue.id);
                    println!("Title: {}", issue.title);
                    println!("Status: {}", issue.status);
                    println!("Priority: {}", issue.priority);
                    println!("Type: {}", issue.issue_type);
                    if !issue.assignee.is_empty() {
                        println!("Assignee: {}", issue.assignee);
                    }
                    if !issue.description.is_empty() {
                        println!("\nDescription:\n{}", issue.description);
                    }
                    if !issue.depends_on.is_empty() {
                        println!("\nDependencies:");
                        for (dep_id, dep_type) in &issue.depends_on {
                            println!("  {} ({})", dep_id, dep_type);
                        }
                    }
                }
            }
            Ok(())
        }

        Commands::Update {
            issue_ids,
            status,
            priority,
            assignee,
            title,
            description,
            design,
            acceptance,
            notes,
            external_ref,
        } => {
            let storage = get_storage(mb_beads_dir, db)?;

            // Log command after storage is validated
            if !mb_no_cmd_logging {
                let _ = log_command(&storage.get_beads_dir(), &env::args().collect::<Vec<_>>());
            }

            let mut updates = HashMap::new();
            if let Some(s) = status {
                updates.insert("status".to_string(), s.to_string());
            }
            if let Some(p) = priority {
                updates.insert("priority".to_string(), p.to_string());
            }
            if let Some(a) = assignee {
                updates.insert("assignee".to_string(), a);
            }
            if let Some(t) = title {
                updates.insert("title".to_string(), t);
            }
            if let Some(d) = description {
                updates.insert("description".to_string(), d);
            }
            if let Some(d) = design {
                updates.insert("design".to_string(), d);
            }
            if let Some(a) = acceptance {
                updates.insert("acceptance_criteria".to_string(), a);
            }
            if let Some(n) = notes {
                updates.insert("notes".to_string(), n);
            }
            if let Some(e) = external_ref {
                updates.insert("external_ref".to_string(), e);
            }

            // Update all specified issues
            let mut updated_issues = Vec::new();
            for issue_id in &issue_ids {
                let issue = storage.update_issue(issue_id, updates.clone())?;
                updated_issues.push(issue);
            }

            if json {
                println!("{}", serde_json::to_string_pretty(&updated_issues)?);
            } else {
                for issue in &updated_issues {
                    println!("Updated issue: {}", issue.id);
                }
            }
            Ok(())
        }

        Commands::Close { issue_ids, reason } => {
            let storage = get_storage(mb_beads_dir, db)?;

            // Log command after storage is validated
            if !mb_no_cmd_logging {
                let _ = log_command(&storage.get_beads_dir(), &env::args().collect::<Vec<_>>());
            }

            // Close all specified issues
            let mut closed_issues = Vec::new();
            for issue_id in &issue_ids {
                let issue = storage.close_issue(issue_id, &reason)?;
                closed_issues.push(issue);
            }

            if json {
                println!("{}", serde_json::to_string_pretty(&closed_issues)?);
            } else {
                for issue in &closed_issues {
                    println!("Closed issue: {}", issue.id);
                }
            }
            Ok(())
        }

        Commands::Reopen {
            issue_ids,
            reason: _,
        } => {
            let storage = get_storage(mb_beads_dir, db)?;

            // Log command after storage is validated
            if !mb_no_cmd_logging {
                let _ = log_command(&storage.get_beads_dir(), &env::args().collect::<Vec<_>>());
            }

            let mut reopened = Vec::new();

            for issue_id in issue_ids {
                let issue = storage.reopen_issue(&issue_id)?;
                reopened.push(issue);
            }

            if json {
                println!("{}", serde_json::to_string_pretty(&reopened)?);
            } else {
                for issue in reopened {
                    println!("Reopened issue: {}", issue.id);
                }
            }
            Ok(())
        }

        Commands::Rename {
            old_id,
            new_id,
            dry_run,
            repair,
        } => {
            let storage = get_storage(mb_beads_dir, db)?;

            // Log command after storage is validated
            if !mb_no_cmd_logging {
                let _ = log_command(&storage.get_beads_dir(), &env::args().collect::<Vec<_>>());
            }

            if repair {
                // Repair mode: scan all issues and fix broken references
                let changes = storage.repair_references(dry_run)?;

                if json {
                    println!("{}", serde_json::to_string_pretty(&changes)?);
                } else if dry_run {
                    println!("Dry run - would make the following changes:");
                    for change in &changes {
                        println!("  {}", change);
                    }
                } else if changes.len() == 1 && changes[0] == "No broken references found" {
                    println!("No broken references found");
                } else {
                    println!("Repaired {} broken reference(s)", changes.len());
                    for change in &changes {
                        println!("  {}", change);
                    }
                }
            } else {
                // Rename mode
                let changes = storage.rename_issue(&old_id, &new_id, dry_run)?;

                if json {
                    println!("{}", serde_json::to_string_pretty(&changes)?);
                } else if dry_run {
                    println!("Dry run - would make the following changes:");
                    for change in &changes {
                        println!("  {}", change);
                    }
                } else {
                    println!("Successfully renamed {} to {}", old_id, new_id);
                    if changes.len() > 2 {
                        println!("Updated {} file(s) with references", changes.len() - 2);
                    }
                }
            }
            Ok(())
        }

        Commands::RenamePrefix {
            new_prefix,
            dry_run,
            force,
        } => {
            let storage = get_storage(mb_beads_dir, db)?;

            // Log command after storage is validated
            if !mb_no_cmd_logging {
                let _ = log_command(&storage.get_beads_dir(), &env::args().collect::<Vec<_>>());
            }

            let changes = storage.rename_prefix(&new_prefix, dry_run, force)?;

            if json {
                println!("{}", serde_json::to_string_pretty(&changes)?);
            } else if dry_run {
                println!("Dry run - would make the following changes:");
                for change in &changes {
                    println!("  {}", change);
                }
            } else {
                println!("Successfully renamed prefix to '{}'", new_prefix);
                println!("Renamed {} issue(s)", changes.len() / 2); // Each issue has 2 changes: file rename + content update
            }
            Ok(())
        }

        Commands::Dep { command } => {
            let storage = get_storage(mb_beads_dir, db)?;

            // Log command after storage is validated
            if !mb_no_cmd_logging {
                let _ = log_command(&storage.get_beads_dir(), &env::args().collect::<Vec<_>>());
            }

            match command {
                DepCommands::Add {
                    issue_id,
                    depends_on_id,
                    r#type,
                } => {
                    storage.add_dependency(&issue_id, &depends_on_id, r#type)?;

                    if !json {
                        println!(
                            "Added dependency: {} depends on {} ({})",
                            issue_id, depends_on_id, r#type
                        );
                    }
                }
                DepCommands::Remove {
                    issue_id,
                    depends_on_id,
                } => {
                    storage.remove_dependency(&issue_id, &depends_on_id)?;

                    if !json {
                        println!(
                            "Removed dependency: {} no longer depends on {}",
                            issue_id, depends_on_id
                        );
                    }
                }
                DepCommands::Tree {
                    issue_id,
                    max_depth,
                    show_all_paths,
                } => {
                    let tree = storage.get_dependency_tree(&issue_id, max_depth, show_all_paths)?;

                    if json {
                        println!("{}", serde_json::to_string_pretty(&tree)?);
                    } else {
                        print_dependency_tree(&tree, 0, "", true);
                    }
                }
                DepCommands::Cycles => {
                    let cycles = storage.detect_dependency_cycles()?;

                    if json {
                        println!("{}", serde_json::to_string_pretty(&cycles)?);
                    } else if cycles.is_empty() {
                        println!("No dependency cycles detected.");
                    } else {
                        println!("Found {} dependency cycle(s):\n", cycles.len());
                        for (i, cycle) in cycles.iter().enumerate() {
                            println!("Cycle {}:", i + 1);
                            for (j, issue_id) in cycle.iter().enumerate() {
                                if j == cycle.len() - 1 {
                                    println!("  {} -> {} (completes cycle)", issue_id, cycle[0]);
                                } else {
                                    println!("  {} ->", issue_id);
                                }
                            }
                            println!();
                        }
                    }
                }
            }
            Ok(())
        }

        Commands::Stats => {
            let storage = get_storage(mb_beads_dir, db)?;

            // Log command after storage is validated
            if !mb_no_cmd_logging {
                let _ = log_command(&storage.get_beads_dir(), &env::args().collect::<Vec<_>>());
            }

            let stats = storage.get_stats()?;

            if json {
                println!("{}", serde_json::to_string_pretty(&stats)?);
            } else {
                println!("Total issues: {}", stats.total_issues);
                println!("Open: {}", stats.open_issues);
                println!("In Progress: {}", stats.in_progress_issues);
                println!("Blocked: {}", stats.blocked_issues);
                println!("Closed: {}", stats.closed_issues);
                println!("Ready: {}", stats.ready_issues);
                println!(
                    "Average lead time: {:.1} hours",
                    stats.average_lead_time_hours
                );
            }
            Ok(())
        }

        Commands::Blocked => {
            let storage = get_storage(mb_beads_dir, db)?;

            // Log command after storage is validated
            if !mb_no_cmd_logging {
                let _ = log_command(&storage.get_beads_dir(), &env::args().collect::<Vec<_>>());
            }

            let blocked = storage.get_blocked()?;

            if json {
                println!("{}", serde_json::to_string_pretty(&blocked)?);
            } else {
                for item in blocked {
                    println!(
                        "{}: {} - blocked by: {}",
                        item.issue.id,
                        item.issue.title,
                        item.blocked_by.join(", ")
                    );
                }
            }
            Ok(())
        }

        Commands::Export {
            output,
            mb_output_default,
            status,
            priority,
            r#type,
            assignee,
        } => {
            let storage = get_storage(mb_beads_dir, db)?;

            // Log command after storage is validated
            if !mb_no_cmd_logging {
                let _ = log_command(&storage.get_beads_dir(), &env::args().collect::<Vec<_>>());
            }

            // Determine output destination
            if let Some(path) = output {
                // -o flag provided: write to specified file
                let count = storage.export_to_jsonl(
                    &path,
                    status,
                    priority,
                    r#type,
                    assignee.as_deref(),
                )?;
                eprintln!("Exported {} issues to {}", count, path.display());
            } else if mb_output_default {
                // --mb-output-default: write to .beads/issues.jsonl
                let path = storage.get_beads_dir().join("issues.jsonl");
                let count = storage.export_to_jsonl(
                    &path,
                    status,
                    priority,
                    r#type,
                    assignee.as_deref(),
                )?;
                eprintln!("Exported {} issues to {}", count, path.display());
            } else {
                // Default: write to stdout (matching upstream bd)
                let issues =
                    storage.list_issues(status, priority, r#type, assignee.as_deref(), None)?;
                for issue in &issues {
                    let json = serde_json::to_string(&issue)?;
                    println!("{}", json);
                }
            }
            Ok(())
        }

        Commands::Sync {
            jsonl,
            dry_run,
            direction,
        } => {
            let storage = get_storage(mb_beads_dir, db)?;

            // Log command after storage is validated
            if !mb_no_cmd_logging {
                let _ = log_command(&storage.get_beads_dir(), &env::args().collect::<Vec<_>>());
            }

            let beads_dir = storage.get_beads_dir();
            let jsonl_path = jsonl.unwrap_or_else(|| beads_dir.join("issues.jsonl"));

            // Load issues from both sources
            let markdown_issues = sync::load_markdown_issues(&beads_dir)?;
            let jsonl_issues = sync::load_jsonl_issues(&jsonl_path)?;

            // Create sync engine and analyze
            let engine = sync::SyncEngine::new();
            let plan = engine.analyze(markdown_issues.clone(), jsonl_issues.clone())?;

            // Filter plan based on direction
            let filtered_plan = match direction.as_str() {
                "both" => plan,
                "to-jsonl" => sync::SyncPlan {
                    markdown_only: plan.markdown_only,
                    jsonl_only: Vec::new(),
                    markdown_newer: plan.markdown_newer,
                    jsonl_newer: Vec::new(),
                    no_change: plan.no_change,
                    conflicts: plan.conflicts,
                },
                "to-markdown" => sync::SyncPlan {
                    markdown_only: Vec::new(),
                    jsonl_only: plan.jsonl_only,
                    markdown_newer: Vec::new(),
                    jsonl_newer: plan.jsonl_newer,
                    no_change: plan.no_change,
                    conflicts: plan.conflicts,
                },
                _ => {
                    anyhow::bail!(
                        "Invalid direction '{}'. Use 'both', 'to-jsonl', or 'to-markdown'",
                        direction
                    );
                }
            };

            // Report plan
            if !json && !filtered_plan.is_empty() {
                println!("Sync plan:");
                if !filtered_plan.markdown_only.is_empty() {
                    println!("  Create in JSONL ({}):", filtered_plan.markdown_only.len());
                    for id in &filtered_plan.markdown_only {
                        println!("    {}", id);
                    }
                }
                if !filtered_plan.jsonl_only.is_empty() {
                    println!("  Create in markdown ({}):", filtered_plan.jsonl_only.len());
                    for id in &filtered_plan.jsonl_only {
                        println!("    {}", id);
                    }
                }
                if !filtered_plan.markdown_newer.is_empty() {
                    println!(
                        "  Update JSONL from markdown ({}):",
                        filtered_plan.markdown_newer.len()
                    );
                    for id in &filtered_plan.markdown_newer {
                        println!("    {}", id);
                    }
                }
                if !filtered_plan.jsonl_newer.is_empty() {
                    println!(
                        "  Update markdown from JSONL ({}):",
                        filtered_plan.jsonl_newer.len()
                    );
                    for id in &filtered_plan.jsonl_newer {
                        println!("    {}", id);
                    }
                }
                if !filtered_plan.conflicts.is_empty() {
                    println!("  Conflicts ({}):", filtered_plan.conflicts.len());
                    for id in &filtered_plan.conflicts {
                        println!("    {}", id);
                    }
                }
                println!();
            }

            // Apply sync
            let report = engine.apply(
                &filtered_plan,
                &markdown_issues,
                &jsonl_issues,
                &beads_dir,
                dry_run,
            )?;

            // Report results
            if json {
                println!("{}", serde_json::to_string_pretty(&report)?);
            } else {
                if dry_run {
                    println!("[DRY RUN] Would make {} changes", report.total_changes());
                } else {
                    println!("Sync complete: {} changes applied", report.total_changes());
                }
                if report.created_in_jsonl > 0 {
                    println!("  Created in JSONL: {}", report.created_in_jsonl);
                }
                if report.created_in_markdown > 0 {
                    println!("  Created in markdown: {}", report.created_in_markdown);
                }
                if report.updated_jsonl > 0 {
                    println!("  Updated JSONL: {}", report.updated_jsonl);
                }
                if report.updated_markdown > 0 {
                    println!("  Updated markdown: {}", report.updated_markdown);
                }
                if report.skipped_conflicts > 0 {
                    println!("  Skipped conflicts: {}", report.skipped_conflicts);
                }
                if !report.errors.is_empty() {
                    println!("\nErrors:");
                    for error in &report.errors {
                        println!("  {}", error);
                    }
                }
            }
            Ok(())
        }

        Commands::Ready {
            assignee,
            priority,
            limit,
            sort,
        } => {
            let storage = get_storage(mb_beads_dir, db)?;

            // Log command after storage is validated
            if !mb_no_cmd_logging {
                let _ = log_command(&storage.get_beads_dir(), &env::args().collect::<Vec<_>>());
            }

            // Validate sort policy
            let sort_policy = match sort.as_str() {
                "priority" | "oldest" | "hybrid" => sort.as_str(),
                _ => {
                    eprintln!("Warning: Invalid sort policy '{}', using 'hybrid'", sort);
                    "hybrid"
                }
            };

            let ready = storage.get_ready(assignee.as_deref(), priority, limit, sort_policy)?;

            if json {
                println!("{}", serde_json::to_string_pretty(&ready)?);
            } else {
                for issue in ready {
                    println!(
                        "{}: {} [priority: {}]",
                        issue.id, issue.title, issue.priority
                    );
                }
            }
            Ok(())
        }

        Commands::Quickstart => {
            print_quickstart();
            Ok(())
        }

        Commands::Version => {
            println!("bd version 0.9.0");
            Ok(())
        }
    }
}

fn get_storage(mb_beads_dir: &Option<PathBuf>, db: &Option<PathBuf>) -> Result<Storage> {
    // Priority order for determining .beads directory:
    // 1. --mb-beads-dir flag (preferred, minibeads-specific)
    // 2. --db flag (for upstream compatibility, treated as syntactic sugar for BEADS_DIR)
    // 3. MB_BEADS_DIR environment variable (minibeads-specific)
    // 4. BEADS_DB environment variable (for upstream compatibility)
    // 5. Search for .beads in current directory and ancestors

    let beads_dir = if let Some(dir) = mb_beads_dir {
        // --mb-beads-dir: use directly
        dir.clone()
    } else if let Some(db_path) = db {
        // --db: syntactic sugar for BEADS_DIR
        // If it points to a .db file, use its parent directory
        if db_path.extension().is_some_and(|e| e == "db") {
            db_path
                .parent()
                .ok_or_else(|| anyhow::anyhow!("Invalid database path"))?
                .to_path_buf()
        } else {
            db_path.clone()
        }
    } else if let Ok(beads_dir) = env::var("MB_BEADS_DIR") {
        PathBuf::from(beads_dir)
    } else if let Ok(beads_db) = env::var("BEADS_DB") {
        let db_path = PathBuf::from(beads_db);
        if db_path.extension().is_some_and(|e| e == "db") {
            db_path
                .parent()
                .ok_or_else(|| anyhow::anyhow!("Invalid BEADS_DB path"))?
                .to_path_buf()
        } else {
            db_path
        }
    } else {
        // Search for .beads directory
        find_beads_dir()?
    };

    Storage::open(beads_dir).context("Failed to open storage")
}

fn find_beads_dir() -> Result<PathBuf> {
    let mut current = env::current_dir()?;

    loop {
        let beads_dir = current.join(".beads");
        if beads_dir.exists() && beads_dir.is_dir() {
            return Ok(beads_dir);
        }

        if !current.pop() {
            anyhow::bail!("No .beads directory found. Run 'bd init' to initialize a new database.");
        }
    }
}

/// Log command to command_history.log
fn log_command(beads_dir: &Path, args: &[String]) -> Result<()> {
    use std::fs::OpenOptions;
    use std::io::Write;

    let log_path = beads_dir.join("command_history.log");
    let timestamp = chrono::Utc::now().to_rfc3339();

    // Skip the first argument (binary path) and quote each CLI argument
    let command_line = if args.len() > 1 {
        args[1..]
            .iter()
            .map(|arg| format!("\"{}\"", arg))
            .collect::<Vec<_>>()
            .join(" ")
    } else {
        String::new()
    };

    let mut file = OpenOptions::new()
        .create(true)
        .append(true)
        .open(&log_path)
        .context("Failed to open command history log")?;

    writeln!(file, "{} {}", timestamp, command_line)
        .context("Failed to write to command history log")?;

    Ok(())
}

fn print_quickstart() {
    println!(
        r#"bd - Dependency-Aware Issue Tracker

Issues chained together like beads.

GETTING STARTED
  bd init   Initialize bd in your project
            Creates .beads/ directory with project-specific database
            Auto-detects prefix from directory name (e.g., myapp-1, myapp-2)

  bd init --prefix api   Initialize with custom prefix
            Issues will be named: api-1, api-2, ...

CREATING ISSUES
  bd create "Fix login bug"
  bd create "Add auth" -p 0 -t feature
  bd create "Write tests" -d "Unit tests for auth" --assignee alice

VIEWING ISSUES
  bd list       List all issues
  bd list --status open  List by status
  bd list --priority 0  List by priority (0-4, 0=highest)
  bd show bd-1       Show issue details

MANAGING DEPENDENCIES
  bd dep add bd-1 bd-2     Add dependency (bd-2 blocks bd-1)

DEPENDENCY TYPES
  blocks  Task B must complete before task A
  related  Soft connection, doesn't block progress
  parent-child  Epic/subtask hierarchical relationship
  discovered-from  Auto-created when AI discovers related work

READY WORK
  bd ready       Show issues ready to work on
            Ready = status is 'open' AND no blocking dependencies
            Perfect for agents to claim next work!

UPDATING ISSUES
  bd update bd-1 --status in_progress
  bd update bd-1 --priority 0
  bd update bd-1 --assignee bob

CLOSING ISSUES
  bd close bd-1
  bd close bd-1 --reason "Fixed in PR #42"

DATABASE LOCATION
  bd automatically discovers your database in this priority order:
    1. --mb-beads-dir /path/to/.beads   (minibeads-specific, preferred)
    2. --db /path/to/.beads             (upstream compatibility)
    3. $MB_BEADS_DIR environment variable
    4. $BEADS_DB environment variable   (upstream compatibility)
    5. .beads/ in current directory or ancestors

  Note: --db is treated as syntactic sugar for specifying BEADS_DIR.
        When path ends with .db, the parent directory is used.
        Use --mb-beads-dir for minibeads-specific workflows.

Ready to start!
Run bd create "My first issue" to create your first issue.
"#
    );
}
