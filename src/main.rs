mod code_patch;
mod format;
mod hash;
mod lock;
mod storage;
mod sync;
mod types;

// Include build-time information generated by build.rs
mod built_info {
    include!(concat!(env!("OUT_DIR"), "/built.rs"));
}

use anyhow::{Context, Result};
use clap::{Parser, Subcommand};
use std::collections::HashMap;
use std::env;
use std::path::{Path, PathBuf};
use storage::Storage;
use types::{DependencyType, IssueType, Status};

/// Generate long version string with git info and build date
fn long_version() -> &'static str {
    // Allocate version string at runtime, leak it to get 'static lifetime
    // This is called once during CLI initialization
    Box::leak(
        {
            let mut version = env!("CARGO_PKG_VERSION").to_string();

            // Add build date from compile time
            version.push_str(&format!("\nBuilt: {}", env!("BUILD_DATE")));

            // Add git commit if available and working copy is clean
            if let (Some(commit), Some(false)) =
                (built_info::GIT_COMMIT_HASH_SHORT, built_info::GIT_DIRTY)
            {
                version.push_str(&format!("\nCommit: {}", commit));
            }

            version
        }
        .into_boxed_str(),
    )
}

#[derive(Parser)]
#[command(
    name = "mb",
    about = "Minibeads - A minimal issue tracker",
    long_version = long_version(),
)]
struct Cli {
    #[command(flatten)]
    global_opts: GlobalOpts,

    #[command(subcommand)]
    command: Commands,
}

#[derive(clap::Args)]
#[command(next_help_heading = "Global Options")]
struct GlobalOpts {
    /// Path to .beads directory (minibeads-specific, preferred over --db)
    #[arg(long = "mb-beads-dir", global = true)]
    mb_beads_dir: Option<PathBuf>,

    /// Path to database (for upstream compatibility - use --mb-beads-dir instead)
    /// Treated as syntactic sugar for specifying the .beads directory.
    /// When path ends with .db, the parent directory is used.
    #[arg(long, global = true)]
    db: Option<PathBuf>,

    /// Actor name for audit trail
    #[arg(long, global = true)]
    actor: Option<String>,

    /// Output JSON format
    #[arg(long, global = true)]
    json: bool,

    /// Validation mode for parsing issues (minibeads-specific)
    #[arg(
        long = "mb-validation",
        global = true,
        default_value = "error",
        value_name = "MODE"
    )]
    mb_validation: ValidationMode,

    /// Disable command logging to .beads/command_history.log (minibeads-specific)
    #[arg(long = "mb-no-cmd-logging", global = true)]
    mb_no_cmd_logging: bool,

    /// Disable auto-flush (ignored for compatibility)
    #[arg(long, global = true)]
    no_auto_flush: bool,

    /// Disable auto-import (ignored for compatibility)
    #[arg(long, global = true)]
    no_auto_import: bool,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum ValidationMode {
    Silent,
    Warn,
    Error,
}

impl std::str::FromStr for ValidationMode {
    type Err = anyhow::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "silent" => Ok(ValidationMode::Silent),
            "warn" => Ok(ValidationMode::Warn),
            "error" => Ok(ValidationMode::Error),
            _ => Err(anyhow::anyhow!(
                "Invalid validation mode: '{}'. Valid values are: silent, warn, error",
                s
            )),
        }
    }
}

#[derive(Subcommand)]
enum Commands {
    /// Initialize beads in current directory
    Init {
        /// Issue prefix (e.g., 'myproject' for myproject-1, myproject-2)
        #[arg(short, long)]
        prefix: Option<String>,

        /// Use hash-based issue IDs instead of sequential numbers (minibeads-specific)
        #[arg(long = "mb-hash-ids")]
        mb_hash_ids: bool,
    },

    /// Create a new issue
    Create {
        /// Issue title
        title: String,

        /// Priority (0-4, 0=highest)
        #[arg(short, long, default_value = "2")]
        priority: i32,

        /// Issue type
        #[arg(short = 't', long, default_value = "task")]
        issue_type: IssueType,

        /// Description
        #[arg(short, long, default_value = "", allow_hyphen_values = true)]
        description: String,

        /// Design notes
        #[arg(long, allow_hyphen_values = true)]
        design: Option<String>,

        /// Acceptance criteria
        #[arg(long, allow_hyphen_values = true)]
        acceptance: Option<String>,

        /// Assignee
        #[arg(short = 'a', long)]
        assignee: Option<String>,

        /// Labels (can be specified multiple times)
        #[arg(short, long)]
        label: Vec<String>,

        /// External reference
        #[arg(long)]
        external_ref: Option<String>,

        /// Explicit issue ID
        #[arg(long)]
        id: Option<String>,

        /// Dependencies (comma-separated). Formats:
        /// Simple: "bd-1,bd-2" (defaults to 'blocks')
        /// Advanced: "blocks:bd-1,related:bd-2,discovered-from:bd-3"
        #[arg(long)]
        deps: Option<String>,
    },

    /// List issues
    List {
        /// Filter by status
        #[arg(short = 's', long)]
        status: Option<Status>,

        /// Filter by priority (comma-separated list, e.g., "1,2,3")
        #[arg(short = 'p', long)]
        priority: Option<String>,

        /// Filter by type
        #[arg(long)]
        r#type: Option<IssueType>,

        /// Filter by assignee
        #[arg(long)]
        assignee: Option<String>,

        /// Filter by labels (must have ALL specified labels)
        #[arg(short = 'l', long = "label")]
        labels: Vec<String>,

        /// Filter by specific issue IDs (comma-separated)
        #[arg(long)]
        id: Option<String>,

        /// Filter by title substring (case-insensitive)
        #[arg(long)]
        title: Option<String>,

        /// Maximum number of issues to return
        #[arg(long)]
        limit: Option<usize>,

        /// Group issues by priority with headers
        #[arg(long)]
        group_priority: bool,
    },

    /// Show issue details
    Show {
        /// Issue IDs (supports shorthand: "14" expands to "prefix-14")
        issue_ids: Vec<String>,
    },

    /// Update one or more issues
    Update {
        /// Issue IDs to update
        issue_ids: Vec<String>,

        /// New status
        #[arg(short = 's', long)]
        status: Option<Status>,

        /// New priority
        #[arg(short, long)]
        priority: Option<i32>,

        /// New assignee
        #[arg(short = 'a', long)]
        assignee: Option<String>,

        /// New title
        #[arg(long, allow_hyphen_values = true)]
        title: Option<String>,

        /// New description
        #[arg(short, long, allow_hyphen_values = true)]
        description: Option<String>,

        /// New design notes
        #[arg(long, allow_hyphen_values = true)]
        design: Option<String>,

        /// New acceptance criteria
        #[arg(long, allow_hyphen_values = true)]
        acceptance: Option<String>,

        /// Additional notes
        #[arg(long, allow_hyphen_values = true)]
        notes: Option<String>,

        /// New external reference
        #[arg(long)]
        external_ref: Option<String>,
    },

    /// Close one or more issues
    Close {
        /// Issue IDs to close
        issue_ids: Vec<String>,

        /// Reason for closing
        #[arg(short, long, default_value = "Completed", allow_hyphen_values = true)]
        reason: String,
    },

    /// Reopen closed issues
    Reopen {
        /// Issue IDs to reopen
        issue_ids: Vec<String>,

        /// Reason for reopening
        #[arg(short, long, allow_hyphen_values = true)]
        reason: Option<String>,
    },

    /// Rename an issue ID (minibeads-specific)
    MbRename {
        /// Current issue ID
        old_id: String,

        /// New issue ID
        new_id: String,

        /// Preview changes without applying them
        #[arg(long)]
        dry_run: bool,

        /// Repair broken references (scan all issues and fix stale references)
        #[arg(long)]
        repair: bool,

        /// Also patch code references (requires interactive TTY) (minibeads-specific)
        #[arg(long = "mb-patch-code")]
        mb_patch_code: bool,
    },

    /// Rename the issue prefix for all issues
    RenamePrefix {
        /// New prefix to use
        new_prefix: String,

        /// Preview changes without applying them
        #[arg(long)]
        dry_run: bool,

        /// Force rename even if issues would conflict
        #[arg(long)]
        force: bool,
    },

    /// Manage dependencies
    Dep {
        #[command(subcommand)]
        command: DepCommands,
    },

    /// Get statistics
    Stats,

    /// Get blocked issues
    Blocked,

    /// Export issues to JSONL format
    Export {
        /// Output file path (defaults to stdout)
        #[arg(short = 'o', long)]
        output: Option<PathBuf>,

        /// Use default file output (.beads/issues.jsonl) instead of stdout
        #[arg(long = "mb-output-default")]
        mb_output_default: bool,

        /// Filter by status
        #[arg(long)]
        status: Option<Status>,

        /// Filter by priority
        #[arg(long)]
        priority: Option<i32>,

        /// Filter by type
        #[arg(long)]
        r#type: Option<IssueType>,

        /// Filter by assignee
        #[arg(long)]
        assignee: Option<String>,
    },

    /// Bidirectional sync between markdown and JSONL formats
    Sync {
        /// Path to JSONL file (defaults to .beads/issues.jsonl)
        #[arg(long)]
        jsonl: Option<PathBuf>,

        /// Preview changes without applying them
        #[arg(long)]
        dry_run: bool,

        /// Direction: 'both' (default), 'to-jsonl', or 'to-markdown'
        #[arg(long, default_value = "both")]
        direction: String,
    },

    /// Find ready work (issues with no blockers)
    Ready {
        /// Filter by assignee
        #[arg(short = 'a', long)]
        assignee: Option<String>,

        /// Filter by priority
        #[arg(short, long)]
        priority: Option<i32>,

        /// Maximum number of issues to return
        #[arg(short = 'n', long, default_value = "10")]
        limit: usize,

        /// Sort policy: priority (by priority), oldest (by creation date), hybrid (priority + age)
        #[arg(short = 's', long, default_value = "hybrid")]
        sort: String,
    },

    /// Show quickstart guide
    Quickstart,

    /// Show version information
    Version,

    /// Migrate between numeric and hash-based IDs (minibeads-specific)
    MbMigrate {
        /// Migration direction: 'hash' (numeric -> hash) or 'numeric' (hash/mixed -> numeric)
        #[arg(long, default_value = "hash")]
        to: String,

        /// Preview changes without applying them
        #[arg(long)]
        dry_run: bool,

        /// Also patch code references (requires interactive TTY) (minibeads-specific)
        #[arg(long = "mb-patch-code")]
        mb_patch_code: bool,

        /// Don't update config-minibeads.yaml (minibeads-specific)
        #[arg(long = "no-change-config")]
        no_change_config: bool,
    },
}

#[derive(Subcommand)]
enum DepCommands {
    /// Add a dependency
    Add {
        /// Issue that has the dependency
        issue_id: String,

        /// Issue that issue_id depends on
        depends_on_id: String,

        /// Dependency type
        #[arg(short = 't', long, default_value = "blocks")]
        r#type: DependencyType,
    },

    /// Remove a dependency
    Remove {
        /// Issue that has the dependency
        issue_id: String,

        /// Issue that issue_id depends on (to remove)
        depends_on_id: String,
    },

    /// Show dependency tree
    Tree {
        /// Issue ID to show tree for (supports shorthand: "14" expands to "prefix-14")
        issue_id: String,

        /// Maximum tree depth to display (safety limit)
        #[arg(short = 'd', long, default_value = "50")]
        max_depth: usize,

        /// Show all paths to nodes (no deduplication for diamond dependencies)
        #[arg(long)]
        show_all_paths: bool,
    },

    /// Detect dependency cycles
    Cycles,
}

/// Print a dependency tree in a visual format
fn print_dependency_tree(node: &types::TreeNode, depth: usize, prefix: &str, is_last: bool) {
    // Print the current node
    let connector = if depth == 0 {
        ""
    } else if is_last {
        "└── "
    } else {
        "├── "
    };

    let dep_type_str = if let Some(ref dt) = node.dep_type {
        format!(" ({})", dt)
    } else {
        String::new()
    };

    let suffix = if node.is_cycle {
        " [CYCLE DETECTED]"
    } else if node.depth_exceeded {
        " [MAX DEPTH EXCEEDED]"
    } else {
        ""
    };

    println!(
        "{}{}{}: {} [{}] (P{}){}{}",
        prefix, connector, node.id, node.title, node.status, node.priority, dep_type_str, suffix
    );

    // Don't recurse if cycle or depth exceeded
    if node.is_cycle || node.depth_exceeded {
        return;
    }

    // Print children
    let child_prefix = if depth == 0 {
        String::new()
    } else if is_last {
        format!("{}    ", prefix)
    } else {
        format!("{}│   ", prefix)
    };

    for (i, child) in node.children.iter().enumerate() {
        let is_last_child = i == node.children.len() - 1;
        print_dependency_tree(child, depth + 1, &child_prefix, is_last_child);
    }
}

fn main() {
    if let Err(e) = run() {
        eprintln!("Error: {:#}", e);
        std::process::exit(1);
    }
}

fn run() -> Result<()> {
    let cli = Cli::parse();

    // Extract fields needed for get_storage before matching on cli.command
    // This avoids borrowing issues when we try to call get_storage(mb_beads_dir, db) inside match arms
    let mb_beads_dir = &cli.global_opts.mb_beads_dir;
    let db = &cli.global_opts.db;
    let json = cli.global_opts.json;
    let mb_no_cmd_logging = cli.global_opts.mb_no_cmd_logging;

    match cli.command {
        Commands::Init {
            prefix,
            mb_hash_ids,
        } => {
            // IMPORTANT: init always creates .beads in current directory
            // It does NOT use find_beads_dir() or respect --db/--mb-beads-dir flags
            // This ensures init always initializes in CWD, never in ancestor directories
            if mb_beads_dir.is_some() || db.is_some() {
                eprintln!("Note: 'mb init' always creates .beads/ in current directory");
                eprintln!("      --db and --mb-beads-dir flags are ignored for 'init'");
            }

            let beads_dir = PathBuf::from(".beads");
            let storage = Storage::init(beads_dir, prefix, mb_hash_ids)?;

            // Log command after successful init
            if !mb_no_cmd_logging {
                let _ = log_command(&storage.get_beads_dir(), &env::args().collect::<Vec<_>>());
            }

            if !json {
                println!(
                    "Initialized beads database with prefix: {}",
                    storage.get_prefix()?
                );
            }
            Ok(())
        }

        Commands::Create {
            title,
            priority,
            issue_type,
            description,
            design,
            acceptance,
            assignee,
            label,
            external_ref,
            id,
            deps,
        } => {
            let storage = get_storage(mb_beads_dir, db)?;

            // Log command after storage is validated
            if !mb_no_cmd_logging {
                let _ = log_command(&storage.get_beads_dir(), &env::args().collect::<Vec<_>>());
            }

            // Parse dependencies
            // Supports two formats:
            // 1. Simple: "bd-1,bd-2" (defaults to 'blocks' type)
            // 2. Advanced: "blocks:bd-1,related:bd-2,discovered-from:bd-3"
            let parsed_deps = if let Some(deps_str) = deps {
                deps_str
                    .split(',')
                    .filter_map(|s| {
                        let s = s.trim();
                        if s.is_empty() {
                            return None;
                        }

                        // Check if it contains a colon (advanced format)
                        if let Some(colon_idx) = s.find(':') {
                            let (type_str, id) = s.split_at(colon_idx);
                            let id = id[1..].trim(); // Skip the colon

                            // Parse the dependency type
                            match type_str.parse::<DependencyType>() {
                                Ok(dep_type) => Some((id.to_string(), dep_type)),
                                Err(_) => {
                                    eprintln!(
                                        "Warning: Invalid dependency type '{}', skipping '{}'",
                                        type_str, s
                                    );
                                    None
                                }
                            }
                        } else {
                            // Simple format: just the ID, default to Blocks
                            Some((s.to_string(), DependencyType::Blocks))
                        }
                    })
                    .collect()
            } else {
                Vec::new()
            };

            let issue = storage.create_issue(
                title,
                description,
                design,
                acceptance,
                priority,
                issue_type,
                assignee,
                label,
                external_ref,
                id,
                parsed_deps,
            )?;

            if json {
                println!("{}", serde_json::to_string_pretty(&issue)?);
            } else {
                println!("Created issue: {}", issue.id);
            }
            Ok(())
        }

        Commands::List {
            status,
            priority,
            r#type,
            assignee,
            labels,
            id,
            title,
            limit,
            group_priority,
        } => {
            let storage = get_storage(mb_beads_dir, db)?;

            // Log command after storage is validated
            if !mb_no_cmd_logging {
                let _ = log_command(&storage.get_beads_dir(), &env::args().collect::<Vec<_>>());
            }

            // Parse comma-separated priorities
            let priority_list = if let Some(priority_str) = priority {
                let priorities: Result<Vec<i32>, _> = priority_str
                    .split(',')
                    .map(|s| s.trim().parse::<i32>())
                    .collect();
                Some(priorities.context("Invalid priority value")?)
            } else {
                None
            };

            let mut issues =
                storage.list_issues(status, priority_list, r#type, assignee.as_deref(), None)?;

            // Apply label filter (must have ALL specified labels)
            if !labels.is_empty() {
                issues.retain(|issue| labels.iter().all(|label| issue.labels.contains(label)));
            }

            // Apply ID filter (comma-separated list of specific IDs)
            if let Some(id_filter) = id {
                let target_ids: Vec<String> =
                    id_filter.split(',').map(|s| s.trim().to_string()).collect();
                issues.retain(|issue| target_ids.contains(&issue.id));
            }

            // Apply title filter (case-insensitive substring match)
            if let Some(title_filter) = title {
                let title_lower = title_filter.to_lowercase();
                issues.retain(|issue| issue.title.to_lowercase().contains(&title_lower));
            }

            // Apply limit if specified
            if let Some(limit_val) = limit {
                issues.truncate(limit_val);
            }

            if json {
                println!("{}", serde_json::to_string_pretty(&issues)?);
            } else if group_priority {
                // Group by priority and display with headers
                use std::collections::BTreeMap;

                // Group issues by priority using BTreeMap for sorted keys
                let mut groups: BTreeMap<i32, Vec<&types::Issue>> = BTreeMap::new();
                for issue in &issues {
                    groups.entry(issue.priority).or_default().push(issue);
                }

                // Display each priority group with header
                for (priority, group_issues) in groups {
                    // Print priority header
                    let header_text = format!("Priority {}", priority);
                    let header_width = 60;
                    let padding = (header_width - header_text.len() - 2) / 2;
                    println!("{}", "=".repeat(header_width));
                    println!(
                        "|{}{}{}|",
                        " ".repeat(padding),
                        header_text,
                        " ".repeat(header_width - padding - header_text.len() - 2)
                    );
                    println!("{}", "=".repeat(header_width));

                    // Print issues in this group (without priority tag)
                    for issue in group_issues {
                        println!("{}: {} [{}]", issue.id, issue.title, issue.status);
                    }
                    println!();
                }
            } else {
                // Standard output
                for issue in issues {
                    println!(
                        "{}: {} [{}] (priority: {})",
                        issue.id, issue.title, issue.status, issue.priority
                    );
                }
            }
            Ok(())
        }

        Commands::Show { issue_ids } => {
            let storage = get_storage(mb_beads_dir, db)?;

            // Log command after storage is validated
            if !mb_no_cmd_logging {
                let _ = log_command(&storage.get_beads_dir(), &env::args().collect::<Vec<_>>());
            }

            if issue_ids.is_empty() {
                anyhow::bail!("No issue IDs provided. Usage: mb show <issue-id> [issue-ids...]");
            }

            let prefix = storage.get_prefix()?;
            let mut issues = Vec::new();

            // Normalize issue IDs (expand numeric shorthand like "14" -> "prefix-14")
            for id_str in &issue_ids {
                let normalized_id = if id_str.parse::<u32>().is_ok() {
                    format!("{}-{}", prefix, id_str)
                } else {
                    id_str.clone()
                };

                let issue = storage
                    .get_issue(&normalized_id)?
                    .ok_or_else(|| anyhow::anyhow!("Issue not found: {}", normalized_id))?;
                issues.push(issue);
            }

            if json {
                println!("{}", serde_json::to_string_pretty(&issues)?);
            } else {
                for (idx, issue) in issues.iter().enumerate() {
                    if idx > 0 {
                        println!("\n{}", "=".repeat(70));
                        println!();
                    }

                    println!("ID: {}", issue.id);
                    println!("Title: {}", issue.title);
                    println!("Status: {}", issue.status);
                    println!("Priority: {}", issue.priority);
                    println!("Type: {}", issue.issue_type);
                    if !issue.assignee.is_empty() {
                        println!("Assignee: {}", issue.assignee);
                    }
                    if !issue.description.is_empty() {
                        println!("\nDescription:\n{}", issue.description);
                    }
                    if !issue.depends_on.is_empty() {
                        println!("\nDependencies:");
                        for (dep_id, dep_type) in &issue.depends_on {
                            println!("  {} ({})", dep_id, dep_type);
                        }
                    }
                }
            }
            Ok(())
        }

        Commands::Update {
            issue_ids,
            status,
            priority,
            assignee,
            title,
            description,
            design,
            acceptance,
            notes,
            external_ref,
        } => {
            let storage = get_storage(mb_beads_dir, db)?;

            // Log command after storage is validated
            if !mb_no_cmd_logging {
                let _ = log_command(&storage.get_beads_dir(), &env::args().collect::<Vec<_>>());
            }

            let mut updates = HashMap::new();
            if let Some(s) = status {
                updates.insert("status".to_string(), s.to_string());
            }
            if let Some(p) = priority {
                updates.insert("priority".to_string(), p.to_string());
            }
            if let Some(a) = assignee {
                updates.insert("assignee".to_string(), a);
            }
            if let Some(t) = title {
                updates.insert("title".to_string(), t);
            }
            if let Some(d) = description {
                updates.insert("description".to_string(), d);
            }
            if let Some(d) = design {
                updates.insert("design".to_string(), d);
            }
            if let Some(a) = acceptance {
                updates.insert("acceptance_criteria".to_string(), a);
            }
            if let Some(n) = notes {
                updates.insert("notes".to_string(), n);
            }
            if let Some(e) = external_ref {
                updates.insert("external_ref".to_string(), e);
            }

            // Update all specified issues
            let mut updated_issues = Vec::new();
            for issue_id in &issue_ids {
                let issue = storage.update_issue(issue_id, updates.clone())?;
                updated_issues.push(issue);
            }

            if json {
                println!("{}", serde_json::to_string_pretty(&updated_issues)?);
            } else {
                for issue in &updated_issues {
                    println!("Updated issue: {}", issue.id);
                }
            }
            Ok(())
        }

        Commands::Close { issue_ids, reason } => {
            let storage = get_storage(mb_beads_dir, db)?;

            // Log command after storage is validated
            if !mb_no_cmd_logging {
                let _ = log_command(&storage.get_beads_dir(), &env::args().collect::<Vec<_>>());
            }

            // Close all specified issues
            let mut closed_issues = Vec::new();
            for issue_id in &issue_ids {
                let issue = storage.close_issue(issue_id, &reason)?;
                closed_issues.push(issue);
            }

            if json {
                println!("{}", serde_json::to_string_pretty(&closed_issues)?);
            } else {
                for issue in &closed_issues {
                    println!("Closed issue: {}", issue.id);
                }
            }
            Ok(())
        }

        Commands::Reopen {
            issue_ids,
            reason: _,
        } => {
            let storage = get_storage(mb_beads_dir, db)?;

            // Log command after storage is validated
            if !mb_no_cmd_logging {
                let _ = log_command(&storage.get_beads_dir(), &env::args().collect::<Vec<_>>());
            }

            let mut reopened = Vec::new();

            for issue_id in issue_ids {
                let issue = storage.reopen_issue(&issue_id)?;
                reopened.push(issue);
            }

            if json {
                println!("{}", serde_json::to_string_pretty(&reopened)?);
            } else {
                for issue in reopened {
                    println!("Reopened issue: {}", issue.id);
                }
            }
            Ok(())
        }

        Commands::MbRename {
            old_id,
            new_id,
            dry_run,
            repair,
            mb_patch_code,
        } => {
            let storage = get_storage(mb_beads_dir, db)?;

            // Log command after storage is validated
            if !mb_no_cmd_logging {
                let _ = log_command(&storage.get_beads_dir(), &env::args().collect::<Vec<_>>());
            }

            if repair {
                // Repair mode: scan all issues and fix broken references
                let changes = storage.repair_references(dry_run)?;

                if json {
                    println!("{}", serde_json::to_string_pretty(&changes)?);
                } else if dry_run {
                    println!("Dry run - would make the following changes:");
                    for change in &changes {
                        println!("  {}", change);
                    }
                } else if changes.len() == 1 && changes[0] == "No broken references found" {
                    println!("No broken references found");
                } else {
                    println!("Repaired {} broken reference(s)", changes.len());
                    for change in &changes {
                        println!("  {}", change);
                    }
                }
            } else {
                // Rename mode
                let changes = storage.rename_issue(&old_id, &new_id, dry_run)?;

                if json {
                    println!("{}", serde_json::to_string_pretty(&changes)?);
                } else if dry_run {
                    println!("Dry run - would make the following changes:");
                    for change in &changes {
                        println!("  {}", change);
                    }
                } else {
                    println!("Successfully renamed {} to {}", old_id, new_id);
                    if changes.len() > 2 {
                        println!("Updated {} file(s) with references", changes.len() - 2);
                    }

                    // Patch code references if requested
                    if mb_patch_code {
                        if let Err(e) = code_patch::patch_code_for_rename(&old_id, &new_id) {
                            eprintln!("Warning: Code patching failed: {}", e);
                        }
                    }
                }
            }
            Ok(())
        }

        Commands::RenamePrefix {
            new_prefix,
            dry_run,
            force,
        } => {
            let storage = get_storage(mb_beads_dir, db)?;

            // Log command after storage is validated
            if !mb_no_cmd_logging {
                let _ = log_command(&storage.get_beads_dir(), &env::args().collect::<Vec<_>>());
            }

            let changes = storage.rename_prefix(&new_prefix, dry_run, force)?;

            if json {
                println!("{}", serde_json::to_string_pretty(&changes)?);
            } else if dry_run {
                println!("Dry run - would make the following changes:");
                for change in &changes {
                    println!("  {}", change);
                }
            } else {
                println!("Successfully renamed prefix to '{}'", new_prefix);
                println!("Renamed {} issue(s)", changes.len() / 2); // Each issue has 2 changes: file rename + content update
            }
            Ok(())
        }

        Commands::Dep { command } => {
            let storage = get_storage(mb_beads_dir, db)?;

            // Log command after storage is validated
            if !mb_no_cmd_logging {
                let _ = log_command(&storage.get_beads_dir(), &env::args().collect::<Vec<_>>());
            }

            match command {
                DepCommands::Add {
                    issue_id,
                    depends_on_id,
                    r#type,
                } => {
                    storage.add_dependency(&issue_id, &depends_on_id, r#type)?;

                    if !json {
                        println!(
                            "Added dependency: {} depends on {} ({})",
                            issue_id, depends_on_id, r#type
                        );
                    }
                }
                DepCommands::Remove {
                    issue_id,
                    depends_on_id,
                } => {
                    storage.remove_dependency(&issue_id, &depends_on_id)?;

                    if !json {
                        println!(
                            "Removed dependency: {} no longer depends on {}",
                            issue_id, depends_on_id
                        );
                    }
                }
                DepCommands::Tree {
                    issue_id,
                    max_depth,
                    show_all_paths,
                } => {
                    let tree = storage.get_dependency_tree(&issue_id, max_depth, show_all_paths)?;

                    if json {
                        println!("{}", serde_json::to_string_pretty(&tree)?);
                    } else {
                        print_dependency_tree(&tree, 0, "", true);
                    }
                }
                DepCommands::Cycles => {
                    let cycles = storage.detect_dependency_cycles()?;

                    if json {
                        println!("{}", serde_json::to_string_pretty(&cycles)?);
                    } else if cycles.is_empty() {
                        println!("No dependency cycles detected.");
                    } else {
                        println!("Found {} dependency cycle(s):\n", cycles.len());
                        for (i, cycle) in cycles.iter().enumerate() {
                            println!("Cycle {}:", i + 1);
                            for (j, issue_id) in cycle.iter().enumerate() {
                                if j == cycle.len() - 1 {
                                    println!("  {} -> {} (completes cycle)", issue_id, cycle[0]);
                                } else {
                                    println!("  {} ->", issue_id);
                                }
                            }
                            println!();
                        }
                    }
                }
            }
            Ok(())
        }

        Commands::Stats => {
            let storage = get_storage(mb_beads_dir, db)?;

            // Log command after storage is validated
            if !mb_no_cmd_logging {
                let _ = log_command(&storage.get_beads_dir(), &env::args().collect::<Vec<_>>());
            }

            let stats = storage.get_stats()?;

            if json {
                println!("{}", serde_json::to_string_pretty(&stats)?);
            } else {
                println!("Total issues: {}", stats.total_issues);
                println!("Open: {}", stats.open_issues);
                println!("In Progress: {}", stats.in_progress_issues);
                println!("Blocked: {}", stats.blocked_issues);
                println!("Closed: {}", stats.closed_issues);
                println!("Ready: {}", stats.ready_issues);
                println!(
                    "Average lead time: {:.1} hours",
                    stats.average_lead_time_hours
                );
            }
            Ok(())
        }

        Commands::Blocked => {
            let storage = get_storage(mb_beads_dir, db)?;

            // Log command after storage is validated
            if !mb_no_cmd_logging {
                let _ = log_command(&storage.get_beads_dir(), &env::args().collect::<Vec<_>>());
            }

            let blocked = storage.get_blocked()?;

            if json {
                println!("{}", serde_json::to_string_pretty(&blocked)?);
            } else {
                for item in blocked {
                    println!(
                        "{}: {} - blocked by: {}",
                        item.issue.id,
                        item.issue.title,
                        item.blocked_by.join(", ")
                    );
                }
            }
            Ok(())
        }

        Commands::Export {
            output,
            mb_output_default,
            status,
            priority,
            r#type,
            assignee,
        } => {
            let storage = get_storage(mb_beads_dir, db)?;

            // Log command after storage is validated
            if !mb_no_cmd_logging {
                let _ = log_command(&storage.get_beads_dir(), &env::args().collect::<Vec<_>>());
            }

            // Determine output destination
            if let Some(path) = output {
                // -o flag provided: write to specified file
                let count = storage.export_to_jsonl(
                    &path,
                    status,
                    priority,
                    r#type,
                    assignee.as_deref(),
                )?;
                eprintln!("Exported {} issues to {}", count, path.display());
            } else if mb_output_default {
                // --mb-output-default: write to .beads/issues.jsonl
                let path = storage.get_beads_dir().join("issues.jsonl");
                let count = storage.export_to_jsonl(
                    &path,
                    status,
                    priority,
                    r#type,
                    assignee.as_deref(),
                )?;
                eprintln!("Exported {} issues to {}", count, path.display());
            } else {
                // Default: write to stdout (matching upstream bd)
                // Convert single priority to vector for list_issues
                let priority_list = priority.map(|p| vec![p]);
                let issues = storage.list_issues(
                    status,
                    priority_list,
                    r#type,
                    assignee.as_deref(),
                    None,
                )?;
                for issue in &issues {
                    let json = serde_json::to_string(&issue)?;
                    println!("{}", json);
                }
            }
            Ok(())
        }

        Commands::Sync {
            jsonl,
            dry_run,
            direction,
        } => {
            let storage = get_storage(mb_beads_dir, db)?;

            // Log command after storage is validated
            if !mb_no_cmd_logging {
                let _ = log_command(&storage.get_beads_dir(), &env::args().collect::<Vec<_>>());
            }

            let beads_dir = storage.get_beads_dir();
            let jsonl_path = jsonl.unwrap_or_else(|| beads_dir.join("issues.jsonl"));

            // Load issues from both sources
            let markdown_issues = sync::load_markdown_issues(&beads_dir)?;
            let jsonl_issues = sync::load_jsonl_issues(&jsonl_path)?;

            // Create sync engine and analyze
            let engine = sync::SyncEngine::new();
            let plan = engine.analyze(markdown_issues.clone(), jsonl_issues.clone())?;

            // Filter plan based on direction
            let filtered_plan = match direction.as_str() {
                "both" => plan,
                "to-jsonl" => sync::SyncPlan {
                    markdown_only: plan.markdown_only,
                    jsonl_only: Vec::new(),
                    markdown_newer: plan.markdown_newer,
                    jsonl_newer: Vec::new(),
                    no_change: plan.no_change,
                    conflicts: plan.conflicts,
                },
                "to-markdown" => sync::SyncPlan {
                    markdown_only: Vec::new(),
                    jsonl_only: plan.jsonl_only,
                    markdown_newer: Vec::new(),
                    jsonl_newer: plan.jsonl_newer,
                    no_change: plan.no_change,
                    conflicts: plan.conflicts,
                },
                _ => {
                    anyhow::bail!(
                        "Invalid direction '{}'. Use 'both', 'to-jsonl', or 'to-markdown'",
                        direction
                    );
                }
            };

            // Report plan
            if !json && !filtered_plan.is_empty() {
                println!("Sync plan:");
                if !filtered_plan.markdown_only.is_empty() {
                    println!("  Create in JSONL ({}):", filtered_plan.markdown_only.len());
                    for id in &filtered_plan.markdown_only {
                        println!("    {}", id);
                    }
                }
                if !filtered_plan.jsonl_only.is_empty() {
                    println!("  Create in markdown ({}):", filtered_plan.jsonl_only.len());
                    for id in &filtered_plan.jsonl_only {
                        println!("    {}", id);
                    }
                }
                if !filtered_plan.markdown_newer.is_empty() {
                    println!(
                        "  Update JSONL from markdown ({}):",
                        filtered_plan.markdown_newer.len()
                    );
                    for id in &filtered_plan.markdown_newer {
                        println!("    {}", id);
                    }
                }
                if !filtered_plan.jsonl_newer.is_empty() {
                    println!(
                        "  Update markdown from JSONL ({}):",
                        filtered_plan.jsonl_newer.len()
                    );
                    for id in &filtered_plan.jsonl_newer {
                        println!("    {}", id);
                    }
                }
                if !filtered_plan.conflicts.is_empty() {
                    println!("  Conflicts ({}):", filtered_plan.conflicts.len());
                    for id in &filtered_plan.conflicts {
                        println!("    {}", id);
                    }
                }
                println!();
            }

            // Apply sync
            let report = engine.apply(
                &filtered_plan,
                &markdown_issues,
                &jsonl_issues,
                &beads_dir,
                dry_run,
            )?;

            // Report results
            if json {
                println!("{}", serde_json::to_string_pretty(&report)?);
            } else {
                if dry_run {
                    println!("[DRY RUN] Would make {} changes", report.total_changes());
                } else {
                    println!("Sync complete: {} changes applied", report.total_changes());
                }
                if report.created_in_jsonl > 0 {
                    println!("  Created in JSONL: {}", report.created_in_jsonl);
                }
                if report.created_in_markdown > 0 {
                    println!("  Created in markdown: {}", report.created_in_markdown);
                }
                if report.updated_jsonl > 0 {
                    println!("  Updated JSONL: {}", report.updated_jsonl);
                }
                if report.updated_markdown > 0 {
                    println!("  Updated markdown: {}", report.updated_markdown);
                }
                if report.skipped_conflicts > 0 {
                    println!("  Skipped conflicts: {}", report.skipped_conflicts);
                }
                if !report.errors.is_empty() {
                    println!("\nErrors:");
                    for error in &report.errors {
                        println!("  {}", error);
                    }
                }
            }
            Ok(())
        }

        Commands::Ready {
            assignee,
            priority,
            limit,
            sort,
        } => {
            let storage = get_storage(mb_beads_dir, db)?;

            // Log command after storage is validated
            if !mb_no_cmd_logging {
                let _ = log_command(&storage.get_beads_dir(), &env::args().collect::<Vec<_>>());
            }

            // Validate sort policy
            let sort_policy = match sort.as_str() {
                "priority" | "oldest" | "hybrid" => sort.as_str(),
                _ => {
                    eprintln!("Warning: Invalid sort policy '{}', using 'hybrid'", sort);
                    "hybrid"
                }
            };

            let ready = storage.get_ready(assignee.as_deref(), priority, limit, sort_policy)?;

            if json {
                println!("{}", serde_json::to_string_pretty(&ready)?);
            } else {
                for issue in ready {
                    println!(
                        "{}: {} [priority: {}]",
                        issue.id, issue.title, issue.priority
                    );
                }
            }
            Ok(())
        }

        Commands::Quickstart => {
            print_quickstart();
            Ok(())
        }

        Commands::Version => {
            println!("mb version 0.10.0");
            Ok(())
        }

        Commands::MbMigrate {
            to,
            dry_run,
            mb_patch_code,
            no_change_config,
        } => {
            let storage = get_storage(mb_beads_dir, db)?;

            // Log command after storage is validated
            if !mb_no_cmd_logging {
                let _ = log_command(&storage.get_beads_dir(), &env::args().collect::<Vec<_>>());
            }

            match to.as_str() {
                "hash" => {
                    let update_config = !no_change_config;
                    let (changes, id_mapping) =
                        storage.migrate_to_hash_ids(dry_run, update_config)?;

                    if json {
                        println!("{}", serde_json::to_string_pretty(&changes)?);
                    } else if dry_run {
                        println!("Dry run - would make the following changes:");
                        for change in &changes {
                            println!("  {}", change);
                        }
                    } else {
                        println!(
                            "Successfully migrated {} issue(s) to hash-based IDs",
                            changes.len() / 3
                        );
                        if update_config {
                            println!("Updated config-minibeads.yaml: mb-hash-ids: true");
                        }

                        // Patch code references if requested
                        if mb_patch_code {
                            if let Err(e) = code_patch::patch_code_for_migration(&id_mapping) {
                                eprintln!("Warning: Code patching failed: {}", e);
                            }
                        }
                    }
                }
                "numeric" => {
                    let update_config = !no_change_config;
                    let (changes, id_mapping) =
                        storage.migrate_to_numeric_ids(dry_run, update_config)?;

                    if json {
                        println!("{}", serde_json::to_string_pretty(&changes)?);
                    } else if dry_run {
                        println!("Dry run - would make the following changes:");
                        for change in &changes {
                            println!("  {}", change);
                        }
                    } else {
                        let issue_count = changes
                            .iter()
                            .filter(|c| c.starts_with("Rename file:"))
                            .count();
                        println!(
                            "Successfully migrated {} issue(s) to numeric IDs",
                            issue_count
                        );
                        if update_config {
                            println!("Updated config-minibeads.yaml: mb-hash-ids: false");
                        }

                        // Patch code references if requested
                        if mb_patch_code {
                            if let Err(e) = code_patch::patch_code_for_migration(&id_mapping) {
                                eprintln!("Warning: Code patching failed: {}", e);
                            }
                        }
                    }
                }
                _ => {
                    anyhow::bail!(
                        "Invalid migration target '{}'. Use '--to=hash' or '--to=numeric'",
                        to
                    );
                }
            }
            Ok(())
        }
    }
}

fn get_storage(mb_beads_dir: &Option<PathBuf>, db: &Option<PathBuf>) -> Result<Storage> {
    // Priority order for determining .beads directory:
    // 1. --mb-beads-dir flag (preferred, minibeads-specific)
    // 2. --db flag (for upstream compatibility, treated as syntactic sugar for BEADS_DIR)
    // 3. MB_BEADS_DIR environment variable (minibeads-specific)
    // 4. BEADS_DB environment variable (for upstream compatibility)
    // 5. Search for .beads in current directory and ancestors

    let beads_dir = if let Some(dir) = mb_beads_dir {
        // --mb-beads-dir: use directly
        dir.clone()
    } else if let Some(db_path) = db {
        // --db: syntactic sugar for BEADS_DIR
        // If it points to a .db file, use its parent directory
        if db_path.extension().is_some_and(|e| e == "db") {
            db_path
                .parent()
                .ok_or_else(|| anyhow::anyhow!("Invalid database path"))?
                .to_path_buf()
        } else {
            db_path.clone()
        }
    } else if let Ok(beads_dir) = env::var("MB_BEADS_DIR") {
        PathBuf::from(beads_dir)
    } else if let Ok(beads_db) = env::var("BEADS_DB") {
        let db_path = PathBuf::from(beads_db);
        if db_path.extension().is_some_and(|e| e == "db") {
            db_path
                .parent()
                .ok_or_else(|| anyhow::anyhow!("Invalid BEADS_DB path"))?
                .to_path_buf()
        } else {
            db_path
        }
    } else {
        // Search for .beads directory
        find_beads_dir()?
    };

    Storage::open(beads_dir).context("Failed to open storage")
}

fn find_beads_dir() -> Result<PathBuf> {
    let mut current = env::current_dir()?;

    loop {
        let beads_dir = current.join(".beads");
        if beads_dir.exists() && beads_dir.is_dir() {
            return Ok(beads_dir);
        }

        if !current.pop() {
            anyhow::bail!("No .beads directory found. Run 'mb init' to initialize a new database.");
        }
    }
}

/// Log command to command_history.log
fn log_command(beads_dir: &Path, args: &[String]) -> Result<()> {
    use std::fs::OpenOptions;
    use std::io::Write;

    let log_path = beads_dir.join("command_history.log");
    let timestamp = chrono::Utc::now().to_rfc3339();

    // Skip the first argument (binary path) and quote each CLI argument
    let command_line = if args.len() > 1 {
        args[1..]
            .iter()
            .map(|arg| format!("\"{}\"", arg))
            .collect::<Vec<_>>()
            .join(" ")
    } else {
        String::new()
    };

    let mut file = OpenOptions::new()
        .create(true)
        .append(true)
        .open(&log_path)
        .context("Failed to open command history log")?;

    writeln!(file, "{} {}", timestamp, command_line)
        .context("Failed to write to command history log")?;

    Ok(())
}

fn print_quickstart() {
    println!(
        r#"mb - Dependency-Aware Issue Tracker

Issues chained together like beads (minibeads).

GETTING STARTED
  mb init   Initialize mb in your project
            Creates .beads/ directory with project-specific database
            Auto-detects prefix from directory name (e.g., myapp-1, myapp-2)

  mb init --prefix api   Initialize with custom prefix
            Issues will be named: api-1, api-2, ...

CREATING ISSUES
  mb create "Fix login bug"
  mb create "Add auth" -p 0 -t feature
  mb create "Write tests" -d "Unit tests for auth" --assignee alice

VIEWING ISSUES
  mb list       List all issues
  mb list --status open  List by status
  mb list --priority 0  List by priority (0-4, 0=highest)
  mb show myapp-1       Show issue details

MANAGING DEPENDENCIES
  mb dep add myapp-1 myapp-2     Add dependency (myapp-2 blocks myapp-1)

DEPENDENCY TYPES
  blocks  Task B must complete before task A
  related  Soft connection, doesn't block progress
  parent-child  Epic/subtask hierarchical relationship
  discovered-from  Auto-created when AI discovers related work

READY WORK
  mb ready       Show issues ready to work on
            Ready = status is 'open' AND no blocking dependencies
            Perfect for agents to claim next work!

UPDATING ISSUES
  mb update myapp-1 --status in_progress
  mb update myapp-1 --priority 0
  mb update myapp-1 --assignee bob

CLOSING ISSUES
  mb close myapp-1
  mb close myapp-1 --reason "Fixed in PR #42"

DATABASE LOCATION
  mb automatically discovers your database in this priority order:
    1. --mb-beads-dir /path/to/.beads   (minibeads-specific, preferred)
    2. --db /path/to/.beads             (upstream compatibility)
    3. $MB_BEADS_DIR environment variable
    4. $BEADS_DB environment variable   (upstream compatibility)
    5. .beads/ in current directory or ancestors

  Note: --db is treated as syntactic sugar for specifying BEADS_DIR.
        When path ends with .db, the parent directory is used.
        Use --mb-beads-dir for minibeads-specific workflows.

COMPATIBILITY NOTE
  The binary is named 'mb' (minibeads) to distinguish it from upstream 'bd'.
  You can symlink 'mb' to 'bd' if needed for compatibility with existing tools.

Ready to start!
Run mb create "My first issue" to create your first issue.
"#
    );
}
